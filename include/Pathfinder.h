#pragma once
#include "Board.h"
#include "KingsManager.h"


// Stores node information for A* 
struct GraphNode {
    Position position; 
    int g; // True cost from start node 
    int h; // Estimated heuristic cost from current node to end 
    int cost() const {return g + h;} // Returns true cpst + heurstic cost -> used for the PQ to organize which nodes to pop first
    
    GraphNode* parent; // parent of this node
 
    GraphNode(Position p, GraphNode* par = nullptr, int g = 0, int h = 0) : position(p), parent(par), g(g), h(h) {}

    bool operator<(const GraphNode& i) const {
        return cost() > i.cost(); // Min heap comparator for PQ 
    }
};

// Node for constraint tree
struct ConstraintTreeNode {
    std::unordered_map<int, std::vector<Position>> pathMap; // Stores king_id -> its path generated by A*
    std::vector<Constraint> constraints; // We populate this when we detect conflicts between two kings at a node in our conflict tree
    int cost; // Total cost of doing all paths in this node, which will be ordered in CBS PQ
    bool operator<(const ConstraintTreeNode& comparare_node) const {
        return cost > comparare_node.cost; // PQ comparator to make it minHeap
    }
};


class Pathfinder {
    public:
    static int calcPathCost(const std::vector<Position>& pos); 
    static int calcTotalCost(const std::unordered_map<int, std::vector<Position>>& paths);
    static std::vector<Position> aStarPath(KingsManager& kings, std::vector<Constraint>& constraints, int king_id, Board& board, std::vector<Move>& moves); // Does A* for 1 king
    static std::vector<std::vector<Position>> allStarPath(KingsManager& kings, std::vector<Constraint>& constraints, Board& board, std::vector<Move>& moves); // Does A* for EVERY king, one by one
    static void updateBoardAndDisplay(std::vector<Position> path, Board& board, int idx); // Updates the board given a path up to idx in the given array, if we want to run path until 5 spot, given 5 = idx
    static void updateBoard(std::vector<Position> path, Board& board, int idx); // Update board, no display
    static int heuristic(const Position& a, const Position& b);
    static bool constrained(int king_id, int time, Position p, std::vector<Constraint>& constraints); // Go through every constraint for a specific king and see if it cannot be at p at time t
    static Conflict* findConflicts(const std::unordered_map<int, std::vector<Position>>& paths); // Detetcts and returns if 2 kings plan to occupy the same space at the same time, aka conflict
    static std::vector<Constraint> createConstraint(const Conflict& conflicts); // When we split a node due to a conflict, we generate 2 constraints and new nodes, one for king1 not being at that pos at that time, and vice versa for king 2
    static std::vector<std::vector<Position>> CBS(KingsManager& kings, Board& board, std::vector<Move>& moves); // Computes the overall conflict based search, using A* as subroutine. If numKings = 5, then we have 5 kings ID'd 1,2,3,4,5. Returns a vector of paths for each king to follow
};